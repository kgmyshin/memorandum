http://www.qcontokyo.com/data_2014/BS4-1_KatoJunichi2.pdf
Scalaを用いた ドメイン駆動設計の実践ノウハウについて かとじゅんさん

概念を表すためにオブジェクトがある
オブジェクトには選び抜かれた目的がある

僕らがよく見るモデル

MVC

Model => 処理をかくところとか説明されることがおおいけど、それなら　ScriptーView-Controllerいいよね。
         そうじゃなくて、ユーザーのメンタルモデルを再現したものがモデルだよね。

Modelはテーブルじゃない


ペットショップでDDD
http://git.io/Cow0xQ

ユビキタスから考える(概念的)
- 戦略的モデリング これ
- 戦術的モデリング

シナリオを選ぶ -> モデルを考える -> モデルを実装する -> シナリオを選ぶ -> ...

ペットショップの日常から概念を引き出す

`顧客が商品を買う`

- 顧客(Costomer)は複数の商品(Item)を購入する
- 商品はカテゴリ(Category)に所属する

=> ペットとペット以外の商品は同じように扱う。ぺっとは特別扱いしない

:


エンティティの実装(値そのものではなく`特定`する必要があるものをEntity)
エンティティにはIDがある

equalsはIDのみでいい
hashCodeもIDのみでいい

概念単位で区切って、特定するひつようのないものはValue Objetにしていく



ドメインモデルのライフサイクル管理

ライフサイクルの責務を分離

エンティティ(Global Entity)、集約 => 生成・永続かを移譲 => リポジトリ、ファクトリ

集約がコレクションのように見える
集約はIOの最小単位

集約(エンティティ) = テーブルではない。それはエンコードの一部でしかない

ORMとかはインフラに行く

OrderItem <=>リポジトリ <=> DB
                      <=> Json
                      <=> ...

リポジトリをサポートするトレイト
store, resolveById, existById, deleteById

リポジトリは外から見るとコレクションに見える

リポジトリはDAOではありません。

リポジトリの関数は全てtryでラップする。必ずIOするので。他の場合もあるけど...

パッケージはドメインで区切っている

リポジトリは定義だけドメイン、実装はインフラ層っていう場合もあるが、インフラ層にドメインのエンティティが出てくるのが微妙なので、ドメインにおいている(解釈違うかも。)
